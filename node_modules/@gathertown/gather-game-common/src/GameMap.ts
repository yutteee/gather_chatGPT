// Note: When adding to or modifying these types, please also adjust the types in modules/gather-http-server/src/v2/db/spaceRoom.ts
import { cloneDeep, range } from "lodash";
import { Buffer } from "buffer";

import { BoundingBox, Point } from "./Position";
import { deserializePoint, getPointFromBoundingBox, serializePoint } from "./positionUtils";
import {
  Announcer,
  AreaPosition,
  Asset,
  DBDesk,
  InteractionEnum_ENUM as Interaction,
  NookDiff,
  Portal,
  Space,
  SpawnPoint,
  TutorialTaskMapArea,
  WireArea,
  WireObject,
  WireTutorialTasks,
} from "./generated_DO_NOT_TOUCH/events";
import { generateNewId } from "./objectUtils";

export { Interaction };
export type CoordsMap<T> = { [y: number]: { [x: number]: T } };

/**
 * GameMap taxonomy:
 *
 * GameMapBaseDoNotUseDirectly -- stuff in common between the types, so we don't re-declare a bunch of stuff
 * GameMapDB -- validated format that is the ONLY format read/written to DB
 * - NOT what is actually in the db; but everything should read the DB via a converter to this type
 * - this is the ideal, fully current map format used by the source of truth
 * - used exclusively server-side where we can enforce atomic updates to it
 * - never EVER expose GameMapDB externally -- should always convert to GameMapHttpPublic first
 * GameMapHttpPublic -- the format exposed via the http API: returned from the getMap endpoint(s) and expected at the setMap endpoint(s)
 * - GameMapHttpPublic is the layer of abstraction between GameMapDB and the 'outside' world,
 *   so we can be deliberate about making externally breaking changes or not.
 * - can't make breaking changes to this without warning! MapMaker and 3rd parties depend on it
 *   so be _very careful_ when doing things with these types, in both read and write directions.
 * - also note: it is correct for the public read and write format to be the same, since a common pattern is to read, modify, write back
 * GameMapMM -- map format used by the mapmaker internally
 * - lives in gather-browser/src/mapmaker/types/GameMapMM.ts
 * GameMap -- the format in gather-game-client
 * - built up from WS API, not related to HTTP
 * - gets the nice name because this is part of the sdk, and is widely used
 * - the two 'external/public' versions are different because they come from different interfaces and are used in different ways.
 *   best example: collisions is a base64 string in GameMapHttpPublic, because you have to download it,
 *   but a boolean[][] in GameMap (game-client), because that's the actually useful format for querying and stuff
 *   (it's sent across the wire as a base64 string as well, but converted for convenience in game-client)
 * - lives in gather-game-client/src/GameMap.ts
 * ClientGameMap -- the format used most places in the browser
 * - heavily based on GameMap, but includes computed fields such as nooksMap
 *
 *
 * additional notes
 * - There is also implicitly the type made up of all the map events sent over the ws connection.
 *   Those are version controlled separately though, and are effectively a conversion between GameMapDB and GameMap.
 * - yes we want to read and write the same format to db -- though on the write side,
 *   there will sometimes have to be additional deletes added in
 * - many conversions will be done both on reads from db and external writes via http;
 *   the conversion functions will likely have shared components but overall be different.
 *   E.g. if a new field is in the db already, it's been migrated, but not necessarily so for external writers
 * - There should be NO CASTS BETWEEN ANY OF THESE TYPES!
 *   The only casting allowed is from db to GameMapDB and _maybe_ external data to GameMapHttpPublic
 *
 */

export interface GameMapBaseDoNotUseDirectly {
  id: string;
  /**
   * Dimensions here are set in _grid_ coordinates.
   * To convert to pixel sizes/world space, multiply these dimensions by `objectSizes`.
   */
  dimensions: [number, number];
  backgroundImagePath: string; // url
  foregroundImagePath?: string;
  sprites?: number[];
  spawn?: Point; // TODO remove
  spawns: SpawnPoint[];
  portals: Portal[];
  announcer: Announcer[];
  assets?: Asset[];
  name?: string; //What is the map actually called
  muteOnEntry?: boolean;
  useDrawnBG?: boolean;
  mostRecentUpdateId?: number;
  areas?: Areas;
  miniMapImagePath?: string;
  enabledChats?: EnabledChat[];
  description?: string;
  decoration?: string;
  tutorialTasks?: TutorialTasks;
  updatedAt?: string;
  script?: string;
  nooks?: NookInfo;
}
// see "GameMap taxonomy" above for documentation on these types

export interface GameMapDB extends Omit<GameMapBaseDoNotUseDirectly, "areas"> {
  walls?: WallFloorDB;
  floors?: WallFloorDB;
  areas?: DBAreas;
  desks?: never;
  collisions: string; // base64 encoded array of dimensions[1] x dimensions[0] bytes
  objects?: MapObjectDB[];
  spaces?: never; // migrated to nooks
  typeCheckFakeField?: null; // this field exists so that typescript will yell at us for mixing up GameMapDB vs Http. It's never used and is harmless
}
// see "GameMap taxonomy" above for documentation on these types

// has to live here because it's used in http server and browser
//   (which makes sense, those are the two sides of the http api)
// this is the PUBLIC type sent and received from the api
export interface GameMapHttpPublic
  extends Omit<GameMapDB, "spaces" | "typeCheckFakeField" | "desks"> {
  spaces?: Space[];
  desks?: Desks;
  typeCheckFakeField?: never; // so TS yells at us for mixing up GameMapDB vs Http (more above)
}
// see "GameMap taxonomy" above for documentation on these types

export type TileEffect = Portal | Space | SpawnPoint | Announcer;

export class WallBlock {
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  x: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  y: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  wallType: number;
}

export class FloorBlock {
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  x: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  y: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  floorType: number;
}

export type WallFloorBlock = WallBlock | FloorBlock;

/*
  In code logic, walls and floors are represented as WallBlock or Floorblock
  In Firestore, for the sake of memory, it is represented as a map:
  {
    floorWallType1 (string): bytearray (string),
    floorWallType2 (string): bytearray (string),
    ...
  }
  where the bytearray is 0x01 if a wall/floor exists there, and 0x00 otherwise
  (like collisions)
*/
export class WallFloorDB {
  [type: string]: string;
}

export interface SpawnTile extends Tile {
  spawnId?: string;
}

export interface NookTile extends Tile {
  nookId: string;
}

export interface PortalTile extends Tile {
  targetX?: number;
  targetY?: number;
  targetMap?: string;
  targetUrl?: string;
}

export interface Tile {
  x: number;
  y: number;
  tileType: TileType;
}

/*
 * Usage:
 * if (isTileType(myTile, TileType.Spawn)) {
 *   myTile // strongly typed as SpawnTile
 * }
 * */
export function isTileType<T extends TileType>(
  tile: Tile,
  type: T,
): tile is T extends TileType.Spawn
  ? SpawnTile
  : T extends TileType.Nook
  ? NookTile
  : T extends TileType.Portal
  ? PortalTile
  : never {
  return tile.tileType === type;
}

type MakeFieldsRequired<T, K extends keyof T> = Required<Pick<T, K>> & T;
type WireMapObjectRequiredFields = "x" | "y" | "normal" | "type" | "width" | "height";
type WireObjectWithRequireds = MakeFieldsRequired<WireObject, WireMapObjectRequiredFields>;

type NookRequiredFields = "nookCoords" | "name";
export type Nook = MakeFieldsRequired<NookDiff, NookRequiredFields>;

// WireObject is defined in events.proto, but uses only optional types, a stringified json for
// an object properties, and a default of empty array for tags, so we replace those here
export interface MapObjectDB extends Omit<WireObjectWithRequireds, "propertiesJson" | "_tags"> {
  _tags?: string[];
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>;
}

export interface MapObject extends MapObjectDB {
  key?: number;
}

// Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function findMissingMapObjectFields(object: any) {
  const requiredFields = ["x", "y", "normal", "type", "width", "height"];
  const missingFields: string[] = [];
  for (const field of requiredFields) {
    if (object[field] === undefined) {
      missingFields.push(field);
    }
  }
  return missingFields;
}

// Note: this function is safe only because we use findMissingMapObjectFields
export function convertWireObjectToMapObjectDB(wireObject: WireObject): MapObjectDB {
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const mapObject: any = cloneDeep(wireObject);
  if (wireObject.propertiesJson) {
    mapObject.properties = JSON.parse(wireObject.propertiesJson);
    delete mapObject.propertiesJson;
  }
  if (wireObject._tags && wireObject._tags.length === 0) {
    delete mapObject._tags;
  }
  if (wireObject.type == null) {
    mapObject.type = 0;
  }
  const missingFields = findMissingMapObjectFields(mapObject);
  if (missingFields.length > 0) {
    throw new Error(
      `Failed to convert to MapObject because the following required fields were missing: ${missingFields}`,
    );
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return mapObject as MapObjectDB;
}
export function convertWireObjectToMapObject(wireObject: WireObject, key: number): MapObject {
  // this cast is unfortunate because if these types diverge more it will silently become unsafe
  // but this is a kinda hot path so I don't want to properly rebuild the object.
  // we can stop doing this once everything treats the objects as a dict and `key` is just the key
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  const obj = convertWireObjectToMapObjectDB(wireObject) as MapObject;
  obj.key = key;
  return obj;
}

export function convertMapObjectToWireObject(mapObject: Partial<MapObjectDB>): WireObject {
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const wireObject: any = cloneDeep(mapObject);
  if (mapObject.properties) {
    wireObject.propertiesJson = JSON.stringify(mapObject.properties);
    delete wireObject.properties;
  }
  if (!mapObject._tags) {
    wireObject._tags = [];
  }
  return wireObject;
}

export enum AreaCategory {
  RW_OFFICE_LOBBY = "RW_OFFICE_LOBBY",
  RW_OFFICE_MEETING = "RW_OFFICE_MEETING",
  COWORKING = "COWORKING",
}

export interface BaseArea {
  category?: AreaCategory;
}

// see comment above
export interface DBArea extends BaseArea {
  coords: AreaPosition[];
}

export interface DBAreas {
  [name: string]: DBArea;
}

export interface Area extends BaseArea {
  coordsMap: CoordsMap<true>;
}

export interface Areas {
  [name: string]: Area;
}

interface WireAreas {
  [name: string]: WireArea;
}

export interface NookInfo {
  [id: string]: Nook;
}

export interface OccupiedNookTilesMap {
  [x: string]: { [y: string]: string };
}

export interface DBDesks {
  [deskId: string]: DBDesk;
}
export interface Desks {
  // 2D array of space, contains desk ID or empty string if no desk
  coordsMap: string[][];
  // map of deskId to the list of coordinates of the desk
  idsMap: { [deskId: string]: Point[] };
}

export function convertWireAreasToDBAreas(wireAreas: WireAreas): DBAreas {
  const dbAreas: DBAreas = {};
  return Object.keys(wireAreas).reduce((dbAreas, areaName) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords, category } = wireAreas[areaName];
    dbAreas[areaName] = { coords };
    if (category) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      dbAreas[areaName].category = convertStringToAreaCategory(category);
    }
    return dbAreas;
  }, dbAreas);
}

export function convertWireAreasToAreas(
  wireAreas: WireAreas,
  dimensions: [number, number] | undefined,
): Areas {
  if (dimensions === undefined) {
    throw new Error("Cannot convert wire areas to areas because dimensions are undefined");
  }
  const areas: Areas = {};
  return Object.keys(wireAreas).reduce((areas, areaName) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords, category } = wireAreas[areaName];
    const coordsMap = convertAreaCoordsToCoordsMap(coords, dimensions);
    areas[areaName] = { coordsMap };
    if (category) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      areas[areaName].category = convertStringToAreaCategory(category);
    }
    return areas;
  }, areas);
}

export function convertAreaCoordsToCoordsMap(
  coords: AreaPosition[],
  [width, height]: [number, number],
): CoordsMap<true> {
  const coordsMap: CoordsMap<true> = {};
  for (const bbox of coords) {
    const positions = getPointFromBoundingBox(bbox, width, height);
    for (const { x, y } of positions) {
      const temp = coordsMap[y] ?? {};
      temp[x] = true;
      coordsMap[y] = temp;
    }
  }
  return coordsMap;
}

export function convertDBDesksCoordsToCoordsMap(dbDesks: DBDesks, [width, height]: number[]) {
  const coordsMap: string[][] = [];
  // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
  // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
  for (let y = 0; y < height; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < width; x++) {
      if (!coordsMap[y]) {
        coordsMap[y] = [];
      }
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = "";
    }
  }

  for (const deskId of Object.keys(dbDesks)) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords } = dbDesks[deskId];

    for (const bbox of coords) {
      const positions = getPointFromBoundingBox(bbox, width, height);
      for (const { x, y } of positions) {
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        coordsMap[y][x] = deskId;
      }
    }
  }
  return coordsMap;
}

export function generateEmptyDeskCoordsMap([width, height]: number[]) {
  const coordsMap: string[][] = [];
  // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
  // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
  for (let y = 0; y < height; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < width; x++) {
      if (!coordsMap[y]) {
        coordsMap[y] = [];
      }
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = "";
    }
  }
  return coordsMap;
}

export function convertDBDesksToDesks(dbDesks: DBDesks, dimensions: number[] | undefined): Desks {
  if (dimensions === undefined) {
    throw new Error("Cannot convert db desks to desks because dimensions are undefined");
  }
  const coordsMap = convertDBDesksCoordsToCoordsMap(dbDesks, dimensions);
  const idsMap = Object.keys(dbDesks).reduce((idsMap, deskId) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords } = dbDesks[deskId];
    const positions = coords.reduce(
      // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
      // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
      (positions, bbox) => [...positions, ...getPointFromBoundingBox(bbox)],
      [],
    );
    return { ...idsMap, [deskId]: positions };
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  }, {} as { [deskId: string]: Point[] });
  return { coordsMap, idsMap };
}

export function convertDesksToDBDesks(desks: Desks): DBDesks {
  const { idsMap } = desks;

  const dbDesks = Object.keys(idsMap).reduce((dbDesks, deskId) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const bboxes = convertCoordsToBBoxes(idsMap[deskId]);
    return { ...dbDesks, [deskId]: { coords: bboxes } };
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  }, {} as DBDesks);

  return dbDesks;
}

export function convertCoordsToBBoxes(coords: Point[]) {
  const coordsSet = new Set(coords.map((coord) => serializePoint(coord)));

  const expandRect = (bbox: BoundingBox): BoundingBox => {
    let { x1, x2, y1, y2 } = bbox;
    let expanded = true;
    while (expanded) {
      expanded = false;
      // expand right
      const rightCoords = range(y1, y2 + 1).map((newY) => ({ x: x2 + 1, y: newY }));
      if (rightCoords.every((coord) => coordsSet.has(serializePoint(coord)))) {
        x2 += 1;
        rightCoords.forEach((coord) => {
          coordsSet.delete(serializePoint(coord));
        });
        expanded = true;
      }

      // expand bottom
      const bottomCoords = range(x1, x2 + 1).map((newX) => ({ x: newX, y: y2 + 1 }));
      if (bottomCoords.every((coord) => coordsSet.has(serializePoint(coord)))) {
        y2 += 1;
        bottomCoords.forEach((coord) => {
          coordsSet.delete(serializePoint(coord));
        });
        expanded = true;
      }

      // expand left
      const leftCoords = range(y1, y2 + 1).map((newY) => ({ x: x1 - 1, y: newY }));
      if (leftCoords.every((coord) => coordsSet.has(serializePoint(coord)))) {
        x1 -= 1;
        leftCoords.forEach((coord) => {
          coordsSet.delete(serializePoint(coord));
        });
        expanded = true;
      }

      // expand top
      const topCoords = range(x1, x2 + 1).map((newX) => ({ x: newX, y: y1 - 1 }));
      if (topCoords.every((coord) => coordsSet.has(serializePoint(coord)))) {
        y1 -= 1;
        topCoords.forEach((coord) => {
          coordsSet.delete(serializePoint(coord));
        });
        expanded = true;
      }
    }
    return { x1, x2, y1, y2 };
  };

  const bboxes: BoundingBox[] = [];
  while (coordsSet.size !== 0) {
    const coord = [...Array.from(coordsSet)].pop() || "";
    coordsSet.delete(coord);
    const { x, y } = deserializePoint(coord);
    const bbox = expandRect({ x1: x, x2: x, y1: y, y2: y });
    bboxes.push(bbox);
  }
  return bboxes;
}

function convertStringToAreaCategory(areaCategory: string): AreaCategory {
  if (!(areaCategory in AreaCategory)) {
    throw new Error("Invalid area category");
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return areaCategory as AreaCategory;
}

// todo @a-lchen rename the Space tile to Nook
export enum TileType {
  Impassable = 1,
  Spawn,
  Portal,
  Announcer,
  Nook,
}

const MODAL_INTERACTIONS = [
  Interaction.EMBEDDED_WEBSITE,
  Interaction.POSTER,
  Interaction.VIDEO,
  Interaction.EXTERNAL_CALL,
  Interaction.NOTE,
  Interaction.MODAL_EXTENSION,
  Interaction.COMPONENT_MODAL,
] as const;

export type ModalInteraction = typeof MODAL_INTERACTIONS[number];

export function interactionOpensModal(i: Interaction) {
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return (MODAL_INTERACTIONS as readonly Interaction[]).includes(i);
}

export function convertNookInfoToOccupiedNookTilesMap(nooks: NookInfo): OccupiedNookTilesMap {
  const occupiedNookTilesMap: OccupiedNookTilesMap = {};

  Object.entries(nooks).forEach(([nookId, nook]) => {
    nook.nookCoords.coords.forEach((coord) => {
      occupiedNookTilesMap[coord.x] = { ...occupiedNookTilesMap[coord.x], [coord.y]: nookId };
    });
  });

  return occupiedNookTilesMap;
}

export function coordsMapToPositions(coordsMap: CoordsMap<true>) {
  const coords: Point[] = [];
  Object.entries(coordsMap).forEach(([y, xObj]) =>
    Object.keys(xObj).forEach((x) => coords.push({ x: parseInt(x), y: parseInt(y) })),
  );
  return coords;
}

export enum EnabledChat {
  GLOBAL_CHAT = "GLOBAL_CHAT",
  LOCAL_CHAT = "LOCAL_CHAT",
  ROOM_CHAT = "ROOM_CHAT",
}

export const wallFloorConvertFromDB: (
  data: WallFloorDB,
  dims: number[],
  isWall: boolean,
) => WallFloorBlock[] = (data, dims, isWall) => {
  const newFormat: WallFloorBlock[] = [];
  Object.keys(data).forEach((type) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const dataBytes = Buffer.from(data[type], "base64");
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let i = 0; i < dims[0]; i++) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      for (let j = 0; j < dims[1]; j++) {
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        if (dataBytes[j * dims[0] + i] === 0x01) {
          const temp = {
            x: i,
            y: j,
          };
          if (isWall) {
            // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
            // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
            temp["wallType"] = parseInt(type);
          } else {
            // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
            // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
            temp["floorType"] = parseInt(type);
          }
          // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
          // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
          newFormat.push(temp as WallFloorBlock);
        }
      }
    }
  });
  return newFormat;
};

export const wallFloorConvertToDB: (data: WallFloorBlock[], dims: number[]) => WallFloorDB = (
  data,
  dims,
) => {
  // data is an array of {x: , y: , type: }
  const newFormat = {};
  data.forEach((point) => {
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    const type = point["floorType"] || point["wallType"];
    if (!(type in newFormat)) {
      // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
      // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
      newFormat[type] = new Array(dims[0] * dims[1]).fill(0x00);
    }
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    newFormat[type][point.y * dims[0] + point.x] = 0x01;
  });
  Object.keys(newFormat).forEach((type) => {
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    newFormat[type] = Buffer.from(newFormat[type]).toString("base64");
  });
  return newFormat;
};

export function convertStringToEnabledChat(enabledChat: string): EnabledChat {
  if (!(enabledChat in EnabledChat)) {
    throw new Error("Invalid enabled chat");
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return enabledChat as EnabledChat;
}

export enum PresetTutorialGroupSetIds {
  ONBOARDING_SANDBOX = "ONBOARDING_SANDBOX",
}

// WireTutorialTasks is defined in events.proto but groupSetId is loosely typed as a string
// and areas is not optional due to limitations in protocol buffers, so we replace those here
export interface TutorialTasks extends Omit<WireTutorialTasks, "groupSetId" | "areas"> {
  groupSetId: PresetTutorialGroupSetIds;
  areas?: TutorialTaskMapArea[];
}

export function convertWireTutorialTasksToTutorialTasks(wireTutorialTasks: WireTutorialTasks) {
  const groupSetId = convertStringToPresetTutorialGroupSetId(wireTutorialTasks.groupSetId);
  return { ...wireTutorialTasks, groupSetId };
}

export function convertTutorialTasksToWireTutorialTasks(
  tutorialTasks: TutorialTasks,
): WireTutorialTasks {
  return { ...tutorialTasks, areas: tutorialTasks.areas ?? [] };
}

export function convertStringToPresetTutorialGroupSetId(presetTutorialGroupSetId: string) {
  if (!(presetTutorialGroupSetId in PresetTutorialGroupSetIds)) {
    throw new Error("Invalid presetTutorialGroupSetId");
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return presetTutorialGroupSetId as PresetTutorialGroupSetIds;
}

export const MAP_MAX_DIMENSION = 9999;

export const nookToDeprecatedSpaces = (nooks?: NookInfo): Space[] => {
  const spaces: Space[] = [];
  if (!nooks) return [];
  Object.keys(nooks).forEach((nookId) => {
    const nook = nooks[nookId];
    if (!nook) return;
    const coords = nook.nookCoords.coords;
    coords.forEach((c) => {
      spaces.push({
        spaceId: nookId,
        x: c.x,
        y: c.y,
        colored: nook.colored,
      });
    });
  });
  return spaces;
};

// When we save to Firebase, periods are interpreted as an accessor to an object key.
// This breaks the format of the nook on save. We can replace the periods with dashes
// since we don't surface IDs to the end user anymore.
const replaceInvalidNookIdCharacters = (nookId: string) => nookId.replace(/\./g, "-");

export const deprecatedSpacesToNooks = (spaces?: Space[]): NookInfo => {
  const nooks: NookInfo = {};
  if (!spaces) return {};
  spaces.forEach((space) => {
    const nookId = replaceInvalidNookIdCharacters(space.spaceId);
    const nook = nooks[nookId];
    if (nook) {
      nook.colored = space.colored;
      nook.nookCoords.coords.push({
        x: space.x,
        y: space.y,
      });
    } else {
      nooks[nookId] = {
        colored: space.colored,
        name: `${nookId}`,
        nookCoords: {
          coords: [
            {
              x: space.x,
              y: space.y,
            },
          ],
        },
        restricted: false,
        allowedUsers: { users: [] },
      };
    }
  });
  return nooks;
};

export const mergeNooks = (
  currentNooks: NookInfo,
  newNooks: { [key: string]: NookDiff },
  overwrite?: boolean,
): NookInfo => {
  let mergedNooks: NookInfo = currentNooks ?? {};
  if (overwrite) {
    // clear the current nooks
    mergedNooks = {};
    Object.entries(newNooks).forEach(([key, value]) => {
      if (value.name && value.nookCoords) {
        mergedNooks[key] = {
          ...value,
          name: value.name,
          nookCoords: value.nookCoords,
        };
      } else {
        throw new Error("Invalid nook found when overwriting, failing");
      }
    });
  } else {
    for (const k in newNooks) {
      const defaultNook = {
        nookCoords: {
          coords: [],
        },
        name: newNooks[k]?.name || k,
        allowedUsers: {
          users: [],
        },
      };
      mergedNooks[k] = {
        ...defaultNook,
        ...currentNooks[k],
        ...newNooks[k],
      };
    }
  }

  return mergedNooks;
};

export const desksToNooks = (desks: DBDesks, nooks: NookInfo): NookInfo =>
  Object.entries(desks).reduce<{ [key: string]: Nook }>((prev, [deskId, desk]) => {
    const coords = desk.coords.reduce<Point[]>(
      (prev, bbox) => [...prev, ...getPointFromBoundingBox(bbox)],
      [],
    );
    const candidateNookId = deskId.replace(/\./g, "-");
    const newNookId = Object.keys(nooks).includes(candidateNookId)
      ? generateNewId(candidateNookId, Object.keys(nooks))
      : candidateNookId;
    return {
      ...prev,
      [newNookId]: { name: deskId, nookCoords: { coords }, isDesk: true },
    };
  }, {});

export interface MapNameAndId {
  name?: string;
  id: string;
}
