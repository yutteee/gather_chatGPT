"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.desksToNooks = exports.mergeNooks = exports.deprecatedSpacesToNooks = exports.nookToDeprecatedSpaces = exports.MAP_MAX_DIMENSION = exports.convertStringToPresetTutorialGroupSetId = exports.convertTutorialTasksToWireTutorialTasks = exports.convertWireTutorialTasksToTutorialTasks = exports.PresetTutorialGroupSetIds = exports.convertStringToEnabledChat = exports.wallFloorConvertToDB = exports.wallFloorConvertFromDB = exports.EnabledChat = exports.coordsMapToPositions = exports.convertNookInfoToOccupiedNookTilesMap = exports.interactionOpensModal = exports.TileType = exports.convertCoordsToBBoxes = exports.convertDesksToDBDesks = exports.convertDBDesksToDesks = exports.generateEmptyDeskCoordsMap = exports.convertDBDesksCoordsToCoordsMap = exports.convertAreaCoordsToCoordsMap = exports.convertWireAreasToAreas = exports.convertWireAreasToDBAreas = exports.AreaCategory = exports.convertMapObjectToWireObject = exports.convertWireObjectToMapObject = exports.convertWireObjectToMapObjectDB = exports.findMissingMapObjectFields = exports.isTileType = exports.WallFloorDB = exports.FloorBlock = exports.WallBlock = exports.Interaction = void 0;
const lodash_1 = require("lodash");
const buffer_1 = require("buffer");
const positionUtils_1 = require("./positionUtils");
const events_1 = require("./generated_DO_NOT_TOUCH/events");
Object.defineProperty(exports, "Interaction", { enumerable: true, get: function () { return events_1.InteractionEnum_ENUM; } });
const objectUtils_1 = require("./objectUtils");
class WallBlock {
}
exports.WallBlock = WallBlock;
class FloorBlock {
}
exports.FloorBlock = FloorBlock;
class WallFloorDB {
}
exports.WallFloorDB = WallFloorDB;
function isTileType(tile, type) {
    return tile.tileType === type;
}
exports.isTileType = isTileType;
function findMissingMapObjectFields(object) {
    const requiredFields = ["x", "y", "normal", "type", "width", "height"];
    const missingFields = [];
    for (const field of requiredFields) {
        if (object[field] === undefined) {
            missingFields.push(field);
        }
    }
    return missingFields;
}
exports.findMissingMapObjectFields = findMissingMapObjectFields;
function convertWireObjectToMapObjectDB(wireObject) {
    const mapObject = (0, lodash_1.cloneDeep)(wireObject);
    if (wireObject.propertiesJson) {
        mapObject.properties = JSON.parse(wireObject.propertiesJson);
        delete mapObject.propertiesJson;
    }
    if (wireObject._tags && wireObject._tags.length === 0) {
        delete mapObject._tags;
    }
    if (wireObject.type == null) {
        mapObject.type = 0;
    }
    const missingFields = findMissingMapObjectFields(mapObject);
    if (missingFields.length > 0) {
        throw new Error(`Failed to convert to MapObject because the following required fields were missing: ${missingFields}`);
    }
    return mapObject;
}
exports.convertWireObjectToMapObjectDB = convertWireObjectToMapObjectDB;
function convertWireObjectToMapObject(wireObject, key) {
    const obj = convertWireObjectToMapObjectDB(wireObject);
    obj.key = key;
    return obj;
}
exports.convertWireObjectToMapObject = convertWireObjectToMapObject;
function convertMapObjectToWireObject(mapObject) {
    const wireObject = (0, lodash_1.cloneDeep)(mapObject);
    if (mapObject.properties) {
        wireObject.propertiesJson = JSON.stringify(mapObject.properties);
        delete wireObject.properties;
    }
    if (!mapObject._tags) {
        wireObject._tags = [];
    }
    return wireObject;
}
exports.convertMapObjectToWireObject = convertMapObjectToWireObject;
var AreaCategory;
(function (AreaCategory) {
    AreaCategory["RW_OFFICE_LOBBY"] = "RW_OFFICE_LOBBY";
    AreaCategory["RW_OFFICE_MEETING"] = "RW_OFFICE_MEETING";
    AreaCategory["COWORKING"] = "COWORKING";
})(AreaCategory = exports.AreaCategory || (exports.AreaCategory = {}));
function convertWireAreasToDBAreas(wireAreas) {
    const dbAreas = {};
    return Object.keys(wireAreas).reduce((dbAreas, areaName) => {
        const { coords, category } = wireAreas[areaName];
        dbAreas[areaName] = { coords };
        if (category) {
            dbAreas[areaName].category = convertStringToAreaCategory(category);
        }
        return dbAreas;
    }, dbAreas);
}
exports.convertWireAreasToDBAreas = convertWireAreasToDBAreas;
function convertWireAreasToAreas(wireAreas, dimensions) {
    if (dimensions === undefined) {
        throw new Error("Cannot convert wire areas to areas because dimensions are undefined");
    }
    const areas = {};
    return Object.keys(wireAreas).reduce((areas, areaName) => {
        const { coords, category } = wireAreas[areaName];
        const coordsMap = convertAreaCoordsToCoordsMap(coords, dimensions);
        areas[areaName] = { coordsMap };
        if (category) {
            areas[areaName].category = convertStringToAreaCategory(category);
        }
        return areas;
    }, areas);
}
exports.convertWireAreasToAreas = convertWireAreasToAreas;
function convertAreaCoordsToCoordsMap(coords, [width, height]) {
    var _a;
    const coordsMap = {};
    for (const bbox of coords) {
        const positions = (0, positionUtils_1.getPointFromBoundingBox)(bbox, width, height);
        for (const { x, y } of positions) {
            const temp = (_a = coordsMap[y]) !== null && _a !== void 0 ? _a : {};
            temp[x] = true;
            coordsMap[y] = temp;
        }
    }
    return coordsMap;
}
exports.convertAreaCoordsToCoordsMap = convertAreaCoordsToCoordsMap;
function convertDBDesksCoordsToCoordsMap(dbDesks, [width, height]) {
    const coordsMap = [];
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!coordsMap[y]) {
                coordsMap[y] = [];
            }
            coordsMap[y][x] = "";
        }
    }
    for (const deskId of Object.keys(dbDesks)) {
        const { coords } = dbDesks[deskId];
        for (const bbox of coords) {
            const positions = (0, positionUtils_1.getPointFromBoundingBox)(bbox, width, height);
            for (const { x, y } of positions) {
                coordsMap[y][x] = deskId;
            }
        }
    }
    return coordsMap;
}
exports.convertDBDesksCoordsToCoordsMap = convertDBDesksCoordsToCoordsMap;
function generateEmptyDeskCoordsMap([width, height]) {
    const coordsMap = [];
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!coordsMap[y]) {
                coordsMap[y] = [];
            }
            coordsMap[y][x] = "";
        }
    }
    return coordsMap;
}
exports.generateEmptyDeskCoordsMap = generateEmptyDeskCoordsMap;
function convertDBDesksToDesks(dbDesks, dimensions) {
    if (dimensions === undefined) {
        throw new Error("Cannot convert db desks to desks because dimensions are undefined");
    }
    const coordsMap = convertDBDesksCoordsToCoordsMap(dbDesks, dimensions);
    const idsMap = Object.keys(dbDesks).reduce((idsMap, deskId) => {
        const { coords } = dbDesks[deskId];
        const positions = coords.reduce((positions, bbox) => [...positions, ...(0, positionUtils_1.getPointFromBoundingBox)(bbox)], []);
        return Object.assign(Object.assign({}, idsMap), { [deskId]: positions });
    }, {});
    return { coordsMap, idsMap };
}
exports.convertDBDesksToDesks = convertDBDesksToDesks;
function convertDesksToDBDesks(desks) {
    const { idsMap } = desks;
    const dbDesks = Object.keys(idsMap).reduce((dbDesks, deskId) => {
        const bboxes = convertCoordsToBBoxes(idsMap[deskId]);
        return Object.assign(Object.assign({}, dbDesks), { [deskId]: { coords: bboxes } });
    }, {});
    return dbDesks;
}
exports.convertDesksToDBDesks = convertDesksToDBDesks;
function convertCoordsToBBoxes(coords) {
    const coordsSet = new Set(coords.map((coord) => (0, positionUtils_1.serializePoint)(coord)));
    const expandRect = (bbox) => {
        let { x1, x2, y1, y2 } = bbox;
        let expanded = true;
        while (expanded) {
            expanded = false;
            const rightCoords = (0, lodash_1.range)(y1, y2 + 1).map((newY) => ({ x: x2 + 1, y: newY }));
            if (rightCoords.every((coord) => coordsSet.has((0, positionUtils_1.serializePoint)(coord)))) {
                x2 += 1;
                rightCoords.forEach((coord) => {
                    coordsSet.delete((0, positionUtils_1.serializePoint)(coord));
                });
                expanded = true;
            }
            const bottomCoords = (0, lodash_1.range)(x1, x2 + 1).map((newX) => ({ x: newX, y: y2 + 1 }));
            if (bottomCoords.every((coord) => coordsSet.has((0, positionUtils_1.serializePoint)(coord)))) {
                y2 += 1;
                bottomCoords.forEach((coord) => {
                    coordsSet.delete((0, positionUtils_1.serializePoint)(coord));
                });
                expanded = true;
            }
            const leftCoords = (0, lodash_1.range)(y1, y2 + 1).map((newY) => ({ x: x1 - 1, y: newY }));
            if (leftCoords.every((coord) => coordsSet.has((0, positionUtils_1.serializePoint)(coord)))) {
                x1 -= 1;
                leftCoords.forEach((coord) => {
                    coordsSet.delete((0, positionUtils_1.serializePoint)(coord));
                });
                expanded = true;
            }
            const topCoords = (0, lodash_1.range)(x1, x2 + 1).map((newX) => ({ x: newX, y: y1 - 1 }));
            if (topCoords.every((coord) => coordsSet.has((0, positionUtils_1.serializePoint)(coord)))) {
                y1 -= 1;
                topCoords.forEach((coord) => {
                    coordsSet.delete((0, positionUtils_1.serializePoint)(coord));
                });
                expanded = true;
            }
        }
        return { x1, x2, y1, y2 };
    };
    const bboxes = [];
    while (coordsSet.size !== 0) {
        const coord = [...Array.from(coordsSet)].pop() || "";
        coordsSet.delete(coord);
        const { x, y } = (0, positionUtils_1.deserializePoint)(coord);
        const bbox = expandRect({ x1: x, x2: x, y1: y, y2: y });
        bboxes.push(bbox);
    }
    return bboxes;
}
exports.convertCoordsToBBoxes = convertCoordsToBBoxes;
function convertStringToAreaCategory(areaCategory) {
    if (!(areaCategory in AreaCategory)) {
        throw new Error("Invalid area category");
    }
    return areaCategory;
}
var TileType;
(function (TileType) {
    TileType[TileType["Impassable"] = 1] = "Impassable";
    TileType[TileType["Spawn"] = 2] = "Spawn";
    TileType[TileType["Portal"] = 3] = "Portal";
    TileType[TileType["Announcer"] = 4] = "Announcer";
    TileType[TileType["Nook"] = 5] = "Nook";
})(TileType = exports.TileType || (exports.TileType = {}));
const MODAL_INTERACTIONS = [
    events_1.InteractionEnum_ENUM.EMBEDDED_WEBSITE,
    events_1.InteractionEnum_ENUM.POSTER,
    events_1.InteractionEnum_ENUM.VIDEO,
    events_1.InteractionEnum_ENUM.EXTERNAL_CALL,
    events_1.InteractionEnum_ENUM.NOTE,
    events_1.InteractionEnum_ENUM.MODAL_EXTENSION,
    events_1.InteractionEnum_ENUM.COMPONENT_MODAL,
];
function interactionOpensModal(i) {
    return MODAL_INTERACTIONS.includes(i);
}
exports.interactionOpensModal = interactionOpensModal;
function convertNookInfoToOccupiedNookTilesMap(nooks) {
    const occupiedNookTilesMap = {};
    Object.entries(nooks).forEach(([nookId, nook]) => {
        nook.nookCoords.coords.forEach((coord) => {
            occupiedNookTilesMap[coord.x] = Object.assign(Object.assign({}, occupiedNookTilesMap[coord.x]), { [coord.y]: nookId });
        });
    });
    return occupiedNookTilesMap;
}
exports.convertNookInfoToOccupiedNookTilesMap = convertNookInfoToOccupiedNookTilesMap;
function coordsMapToPositions(coordsMap) {
    const coords = [];
    Object.entries(coordsMap).forEach(([y, xObj]) => Object.keys(xObj).forEach((x) => coords.push({ x: parseInt(x), y: parseInt(y) })));
    return coords;
}
exports.coordsMapToPositions = coordsMapToPositions;
var EnabledChat;
(function (EnabledChat) {
    EnabledChat["GLOBAL_CHAT"] = "GLOBAL_CHAT";
    EnabledChat["LOCAL_CHAT"] = "LOCAL_CHAT";
    EnabledChat["ROOM_CHAT"] = "ROOM_CHAT";
})(EnabledChat = exports.EnabledChat || (exports.EnabledChat = {}));
const wallFloorConvertFromDB = (data, dims, isWall) => {
    const newFormat = [];
    Object.keys(data).forEach((type) => {
        const dataBytes = buffer_1.Buffer.from(data[type], "base64");
        for (let i = 0; i < dims[0]; i++) {
            for (let j = 0; j < dims[1]; j++) {
                if (dataBytes[j * dims[0] + i] === 0x01) {
                    const temp = {
                        x: i,
                        y: j,
                    };
                    if (isWall) {
                        temp["wallType"] = parseInt(type);
                    }
                    else {
                        temp["floorType"] = parseInt(type);
                    }
                    newFormat.push(temp);
                }
            }
        }
    });
    return newFormat;
};
exports.wallFloorConvertFromDB = wallFloorConvertFromDB;
const wallFloorConvertToDB = (data, dims) => {
    const newFormat = {};
    data.forEach((point) => {
        const type = point["floorType"] || point["wallType"];
        if (!(type in newFormat)) {
            newFormat[type] = new Array(dims[0] * dims[1]).fill(0x00);
        }
        newFormat[type][point.y * dims[0] + point.x] = 0x01;
    });
    Object.keys(newFormat).forEach((type) => {
        newFormat[type] = buffer_1.Buffer.from(newFormat[type]).toString("base64");
    });
    return newFormat;
};
exports.wallFloorConvertToDB = wallFloorConvertToDB;
function convertStringToEnabledChat(enabledChat) {
    if (!(enabledChat in EnabledChat)) {
        throw new Error("Invalid enabled chat");
    }
    return enabledChat;
}
exports.convertStringToEnabledChat = convertStringToEnabledChat;
var PresetTutorialGroupSetIds;
(function (PresetTutorialGroupSetIds) {
    PresetTutorialGroupSetIds["ONBOARDING_SANDBOX"] = "ONBOARDING_SANDBOX";
})(PresetTutorialGroupSetIds = exports.PresetTutorialGroupSetIds || (exports.PresetTutorialGroupSetIds = {}));
function convertWireTutorialTasksToTutorialTasks(wireTutorialTasks) {
    const groupSetId = convertStringToPresetTutorialGroupSetId(wireTutorialTasks.groupSetId);
    return Object.assign(Object.assign({}, wireTutorialTasks), { groupSetId });
}
exports.convertWireTutorialTasksToTutorialTasks = convertWireTutorialTasksToTutorialTasks;
function convertTutorialTasksToWireTutorialTasks(tutorialTasks) {
    var _a;
    return Object.assign(Object.assign({}, tutorialTasks), { areas: (_a = tutorialTasks.areas) !== null && _a !== void 0 ? _a : [] });
}
exports.convertTutorialTasksToWireTutorialTasks = convertTutorialTasksToWireTutorialTasks;
function convertStringToPresetTutorialGroupSetId(presetTutorialGroupSetId) {
    if (!(presetTutorialGroupSetId in PresetTutorialGroupSetIds)) {
        throw new Error("Invalid presetTutorialGroupSetId");
    }
    return presetTutorialGroupSetId;
}
exports.convertStringToPresetTutorialGroupSetId = convertStringToPresetTutorialGroupSetId;
exports.MAP_MAX_DIMENSION = 9999;
const nookToDeprecatedSpaces = (nooks) => {
    const spaces = [];
    if (!nooks)
        return [];
    Object.keys(nooks).forEach((nookId) => {
        const nook = nooks[nookId];
        if (!nook)
            return;
        const coords = nook.nookCoords.coords;
        coords.forEach((c) => {
            spaces.push({
                spaceId: nookId,
                x: c.x,
                y: c.y,
                colored: nook.colored,
            });
        });
    });
    return spaces;
};
exports.nookToDeprecatedSpaces = nookToDeprecatedSpaces;
const replaceInvalidNookIdCharacters = (nookId) => nookId.replace(/\./g, "-");
const deprecatedSpacesToNooks = (spaces) => {
    const nooks = {};
    if (!spaces)
        return {};
    spaces.forEach((space) => {
        const nookId = replaceInvalidNookIdCharacters(space.spaceId);
        const nook = nooks[nookId];
        if (nook) {
            nook.colored = space.colored;
            nook.nookCoords.coords.push({
                x: space.x,
                y: space.y,
            });
        }
        else {
            nooks[nookId] = {
                colored: space.colored,
                name: `${nookId}`,
                nookCoords: {
                    coords: [
                        {
                            x: space.x,
                            y: space.y,
                        },
                    ],
                },
                restricted: false,
                allowedUsers: { users: [] },
            };
        }
    });
    return nooks;
};
exports.deprecatedSpacesToNooks = deprecatedSpacesToNooks;
const mergeNooks = (currentNooks, newNooks, overwrite) => {
    var _a;
    let mergedNooks = currentNooks !== null && currentNooks !== void 0 ? currentNooks : {};
    if (overwrite) {
        mergedNooks = {};
        Object.entries(newNooks).forEach(([key, value]) => {
            if (value.name && value.nookCoords) {
                mergedNooks[key] = Object.assign(Object.assign({}, value), { name: value.name, nookCoords: value.nookCoords });
            }
            else {
                throw new Error("Invalid nook found when overwriting, failing");
            }
        });
    }
    else {
        for (const k in newNooks) {
            const defaultNook = {
                nookCoords: {
                    coords: [],
                },
                name: ((_a = newNooks[k]) === null || _a === void 0 ? void 0 : _a.name) || k,
                allowedUsers: {
                    users: [],
                },
            };
            mergedNooks[k] = Object.assign(Object.assign(Object.assign({}, defaultNook), currentNooks[k]), newNooks[k]);
        }
    }
    return mergedNooks;
};
exports.mergeNooks = mergeNooks;
const desksToNooks = (desks, nooks) => Object.entries(desks).reduce((prev, [deskId, desk]) => {
    const coords = desk.coords.reduce((prev, bbox) => [...prev, ...(0, positionUtils_1.getPointFromBoundingBox)(bbox)], []);
    const candidateNookId = deskId.replace(/\./g, "-");
    const newNookId = Object.keys(nooks).includes(candidateNookId)
        ? (0, objectUtils_1.generateNewId)(candidateNookId, Object.keys(nooks))
        : candidateNookId;
    return Object.assign(Object.assign({}, prev), { [newNookId]: { name: deskId, nookCoords: { coords }, isDesk: true } });
}, {});
exports.desksToNooks = desksToNooks;
//# sourceMappingURL=GameMap.js.map